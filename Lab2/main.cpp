// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.
#include "Shape.h"
#include "Rect.h"
#include "Circle.h"
#include "Bytes.h"
#include "Bin.h"
#include "Oct.h"
#include "Hex.h"
#include <tchar.h>
#define	  stop __asm nop

int _tmain(int argc, _TCHAR* argv[])
{


	//Задание 1.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.

	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);
	

	
	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов
	
	{
		//Shape S1(4,4,BLACK); //,базовый класс, вызов конструктора
	}//базовый класс, вызов деструктора
	
	{
		Rect R1(1, 10, 10, 1, RED);	//вызов конструткора класса Rect
	}//вызов деструктора Rect

	{
		Circle C1(3, 3, 8, GREEN); //вызов конструткора класса Circle
	}//вызов деструктора класса Circle

	stop
//////////////////////////////////////////////////////////////////////

	//Задание 2.Виртуальные функции.
	//2а) Модифицируйте классы Shape,Rect и Circle:
	//добавьте в каждый класс public метод void WhereAmI().
	//Реализация каждой функции должна выводить сообщение 
	//следующего вида "Now I am in class Shape(Rect или Circle)".
	//Выполните приведенный фрагмент, объясните результат.

	//2б) Сделайте метод WhereAmI() виртуальным.
	//Снова выполните приведенный фрагмент, объясните разницу.

	{
		//Shape s(2,2, WHITE);
		Rect r(2, 20, 20, 2, YELLOW);
		Circle c(10,10, BLUE);

	
		//Метод какого класса вызывается в следующих строчках???

		//механизм полиморфизма задействуется только в тех случаях, когда вызов методов осуществляется посредством адреса объекта
		//s.WhereAmI();	//метод Shape в обоих случаях
		r.WhereAmI();	//метод Rect в обоих случаях
		c.WhereAmI();	//метод Circle в обоих случаях
		stop

		//указатели базового типа
		//Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;

		//1ый фрагмент - методы базового класса, т.к. указатели базового типа
		//2ой фрагмент - метод стал полиморфным, вызываются методы производных классов - косвенно посредством таблицы вирутальных функций
    	//pShape->WhereAmI();	//	базовый класс, всегда метод базового класса
		pRect->WhereAmI();	//	1ый фрагмент - метод базового класса, 2ой фрагмент метод класса Rect
		pCircle->WhereAmI(); //	1ый фрагмент - метод базового класса, 2ой фрагмент метод класса Circle
		stop

		//ссылки базового типа
		//Заполните ... согласно комментариям
		//Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r
		Shape& rCircle = c; //псевдоним c

		//1ый фрагмент - методы базового класса, т.к. ссылки базового типа
		//2ой фрагмент - метод стал полиморфным, вызываются методы производных классов - косвенно посредством таблицы вирутальных функций
    	//rShape.WhereAmI();	//базовый класс, всегда метод базового класса
		rRect.WhereAmI();	//	1ый фрагмент - метод базового классас, 2ой фрагмент метод класса Rect
		rCircle.WhereAmI(); //	1ый фрагмент - метод базового класса, 2ой фрагмент метод класса Circle
		stop
	}


//////////////////////////////////////////////////////////////////////

	//Задание 3.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.

	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.

	
	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте

		//не хватает освобождения памяти и конструктора для Circle
		//компилятор неправильно высчитывает адрес

		Rect r(1, 10, 10, 1, RED); //вызывается конструктор с параметрами
		Shape* ar[]={new Rect(r), new Rect(r), new Circle(r), new Circle() }; //для первых двух объектов- конструктор копирования
		// 3 -конструктор с параметрами, 4 - конструктор с параметрами по умолчанию

		//Вызовите для каждого элемента массива метод WhereAmI()

		//1 фрагмент - при освобождении памяти вызываются только деструкторы базового класса, так как указатели типа Shape*
		//производные части Rect и Circle не будут корректно освобождены
		//2 фрагмент - при i=0 вызывается деструктор Shape, при следующих i сначала деструктор производного класса (Rect/Circle), затем деструктор базового
		for (size_t i = 0; i < (sizeof(ar) / sizeof(ar[0])); i++)
		{
			ar[i]->WhereAmI();
			delete ar[i]; //вызов деструкторов
		}

		//for (size_t i = 0; i < (sizeof(ar)/sizeof(ar[0])); i++)
		//{
		//	delete ar[i];
		//}

	stop



	//Задание 4*. В чем заключается отличие 1) и 2)
	{
		Shape* pShapes = new Rect[10];//1) указатель базового типа на одномерный массив объектов типа Rect
		stop
		Rect* pRects = new Rect[10];//2) указатель типа Rect на одномерный массив объектов типа Rect
		stop

			Rect* nRects = static_cast<Rect*>(pShapes);

		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема???

		//для каждого элемента вызов конструктора по умолчанию
		for (size_t i = 0; i < 10; i++)
		{
			static_cast<Rect*>(pShapes)[i].WhereAmI();
			//nRects[i].WhereAmI();
		}
		

		for (size_t i = 0; i < 10; i++)
		{
			pRects[i].WhereAmI();
		}

		//Освободите динамически захваченную память
		delete[] pShapes;
		delete[] pRects;
		stop
	}



//////////////////////////////////////////////////////////////////////

	//Задание 5.Виртуальные функции и оператор разрешения области видимости. 

	{
		Rect r(1, 10, 10, 1, ORANGE);
		Shape* p = &r;	
		p->WhereAmI();//генерируется косвенный вызов метода посредством таблицы виртуальных функций, Rect::WhereAmI()
		stop


			//4a Оператор разрешения области видимости.
			//Посредством объекта r и указателя p вызовите виртуальную функцию
			//WhereAmI()класса Shape

			p->Shape::WhereAmI(); //вызов генерируется на этапе компиляции, Shape::WhereAmI()
	}


//////////////////////////////////////////////////////////////////////

	//Задание 6.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		//метод Inflate(int) объявляем чисто виртуальным
		Rect r(1, 10, 10, 1, GREEN);
		Shape* p = &r;
		p->Inflate(5);
		Circle c(5, 5, 10, RED);
		p = &c;
		p->Inflate(5);
		stop
	}


//////////////////////////////////////////////////////////////////////

	//Задание 7.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	Bytes byte(0x1f);
	byte.ShowDec();
	byte.ShowChar();
	byte.ShowHex();
	byte.ShowOct();
	byte.ShowBin();
	byte.ShowBinPos(3);
	byte.ShowOctPos(1);
	byte.ShowHexPos(0);
	byte.EditBin(6, 1);
	byte.EditOct(0,2);
	byte.EditHex(1, 9);
	//...

	stop

	return 0;
}//endmain


