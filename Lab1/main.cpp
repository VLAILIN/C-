#include "myRect.h"
#include "myString.h"
#include "Bochka.h"
#include <iostream>

#define stop __asm nop

void main()
{
using namespace std;

	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
	{
		Rect rect; //конструктор по умолчанию, созданный компилятором, вызывается неявно
		stop
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	Rect rect_par(5, 15, 20, 5); //при создании объекта вызов конструктора с параметрами

	stop
		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем

		Rect rect_z;
	
	//1в. Подумайте, как следует поступать в случае, когда пользователь задал
	//координаты следующим образом:

	Rect rrr(4,3,2,1);
	 //необходимо нормализовать прямоугольник, поменять местами координаты left right

	stop
		//1г. Объявите, определите и вызовите метод класса InflateRect(), 
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.

		rrr.InflateRect(2, 2, 2, 2);

	stop


	//Задание 2.Перегрузка конструкторов и методов класса.
	//Конструктор копирования.

	//2а.Объявите и определите конструктор копирования в классе Rect.
	//Выполняя задание по шагам, определите, какой
	//конструктор вызывается при создании r1,r2,r3 и r4?
	//Чему равны переменные созданных объектов?

		Rect r1; //конструктор без параметров, нули
		Rect r2(1,2,3,4); //конструктор с параметрами, 1,2,3,4
		Rect r3 = r1;  //конструктор копирования, нули
		Rect r4(r2); //конструктор копирования, 1,2,3,4
		stop


  //2б. Объявите и определите в классе Rect метод InflateRect(),
	//который принимает два аргумента, по умолчанию равных 1, и 
	//раздвигает стороны прямоугольника на на заданные приращения.
	//Для каких объектов вызывается функция InflateRect()?
		r1.InflateRect(1,1);	//для объекта r1
		r2.InflateRect(2,2);	//для объекта r2
	//Какая из функций InflateRect() вызывается в каждом из трех случаев?
		r3.InflateRect(2,2,2,2); //первая функция с 4 параметрами
		r3.InflateRect(3,3); //вторая функция с параметрами по умолчанию
		r3.InflateRect(5); //вторая функция с параметрами по умолчанию
		r3.InflateRect(); //вторая функция с параметрами по умолчанию
	stop


	
	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

	//int tmp = r.m_left; //переменные, объявленные после спецификатора доступа private, доступны только внутри класса

	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 

	r.SetAll(1, 10, 10, 1);
	stop

		//Введите в класс Rect парный метод GetAll(...),
		//который "достает" значения private-переменных класса.
		//Вызовите созданный метод, проверьте корректность. 

	int t_left = 0, t_right = 0, t_top = 0, t_bottom = 0; //переменные для хранения значений private-переменных класса

	r.GetAll(t_left, t_right, t_top, t_bottom); //вызов метода

	//вывод на экран
	cout << "left = " << t_left<<endl;
	cout << "right = " << t_right <<endl;
	cout << "top = " << t_top <<endl;
	cout << "bottom = " << t_bottom <<endl;

	stop
	}


	//Задание 4.Передача экземпляра класса в качестве параметра
	//функции. Возвращение объекта класса по значению. Поставив
	//остановы в конструкторе копирования или выполняя фрагмент
	//по шагам, определите: в какой момент происходит обращение
	//к конструктору копирования. 
	//Создайте глобальную функцию 
	// Rect BoundingRect(Rect, Rect);
	//которая принимает два объекта класса Rect по значению и
	//возвращает объект класса Rect, который является прямоугольником,
	//в который вписаны заданные прямоугольники. Как происходит
	//передача параметров и возвращение объекта класса?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom

	{

		Rect r1(1,2,3,4), r2(5,6,7,8),r3;
		r3= BoundingRect(r1, r2);
	stop
	
	//Задание 4а. Передача объектов по ссылке.
	//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
	//задачу, принимая параметры по ссылке
	//Вызываются ли конструкторы при передаче параметров?
	

	r3 = BoundingRect2(r1, r2); //при передаче параметров конструкторы не вызываются, так как в функции мы работаем с оригиналами объектов
	stop
	}




	//Задание 5. Указатель на класс. Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1; //конструктор по умолчанию
		Rect*	pR = new Rect(1,2,1,2);	 //конструктор с параметрами
		{
			Rect r2(r1); //конструктор копирования
			Rect arRect[2]; ////конструктор по умолчанию для каждого объекта массива
			for(int i=0; i<3; i++)
			{
				static Rect r3 (i,i,i,i) ; //на первой итерации конструктор с параметрами
				Rect r4(*pR); ////на каждой итерации конструктор копирования
				Rect r5(i,i,i,i); //на каждой итерации конструктор с параметрами
			} //на каждой итерации деструктор r5 затем r4
		} //деструктор каждого объекта массива и деструктор r2
		delete pR;	//деструктор pR 
		stop
	} //деструктор r1

 
	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString	str("It's my string!");
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str
		//Замечание: подумайте, как следует корректно реализовать метод GetString().

		cout << str.GetString()<<endl;
		//str.GetString()[1] = 'g';
		const MyString	str1("string!");
		cout << str1.GetString() << endl;
	}
	stop


	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)
		{
			MyString str1("The first string!");
			MyString str2 = str1;// будет скопирован указатель, необходим конструктор копирования
		}
		stop

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую

		{
			MyString str9("The second string!");
			str9.SetNewString("The new string!!!");
			cout << str9.GetString()<<endl;
		}
		stop
	


	//6г. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров
		{
			MyString str3 = Сoncat_str("C++", "forever", "!!!", nullptr);
			cout << str3.GetString() << endl;
		}
	


	//Задание 7.Массив объектов класса.
	{
	//Объявите и проинициализируйте массив ar из объектов
	// типа MyString. Например:
	//Как задать размерность? N=3
		const int N = 5;
		MyString arstr[N] = {MyString("String1"), MyString("String2"), MyString("String3")};

				//Проверка - печать строк-членов класса
			for (int i = 0; i < N; i++)
			{
				cout << arstr[i].GetString() << endl;
			}

				//Увеличьте размер массива, не изменяя список инициализаторов:
				//N=5???
			


				//Объявите и проинициализируйте массив объектов	типа Rect.

		Rect r[5]; //конструкторы по умолчанию

	}
	stop


	//Задание 8.Массив указателей на объекты класса.
	{
	//Объявите и проинициализируйте массив arPtr из трех 
	//указателей на объекты типа MyString.
	
	MyString str5("String5"), str6("String6"), str7("String7");
	MyString* arPtr[5] = {&str5, &str6, &str7};
	
	//Печать строк-членов класса
		for (int i = 0; i < 5; i++)
			{
				cout << arPtr[i]->GetString() << endl;
			}
  
	}
	stop

	//Задание 9.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	Bochka spirt(4, 96);
	Bochka water(100, 0);
	unsigned int i = 0; //итерация
	//...
	while(spirt.ProcentSpirt() > 50)
	{
			spirt.Pereliv(water,1); //или spirt.Pereliv(water, объем_кружки);
			water.Pereliv(spirt, 1); // аналогично
			cout<<"iteration = "<<i<<endl;
			spirt.Print();
			i++;
	}

}//end_main

